     1                                  %include "linux64.inc"
     1                              <1> Section .bss
     2 00000000 <res 00000064>      <1> 	digitSpace resb 100
     3 00000064 <res 00000008>      <1> 	digitSpacePos resb 8
     4 0000006C <res 00000008>      <1> 	printSpace resb 8
     5                              <1> %macro print 1
     6                              <1> 	mov rax, %1
     7                              <1> 	mov [printSpace], rax
     8                              <1> 	mov rbx, 0
     9                              <1> %%printLoop:
    10                              <1> 	mov cl, [rax]
    11                              <1> 	cmp cl, 0
    12                              <1> 	je %%endPrintLoop
    13                              <1> 	inc rbx
    14                              <1> 	inc rax
    15                              <1> 	jmp %%printLoop
    16                              <1> %%endPrintLoop:
    17                              <1> 	mov rax, SYS_WRITE
    18                              <1> 	mov rdi, STDIN
    19                              <1> 	mov rsi, [printSpace]
    20                              <1> 	mov rdx, rbx
    21                              <1> 	syscall
    22                              <1> %endmacro
    23                              <1> 
    24                              <1> %macro printVal 1
    25                              <1> 	mov rax, %1
    26                              <1> %%printRAX:
    27                              <1> 	mov rcx, digitSpace
    28                              <1> ;	mov rbx, 10
    29                              <1> ;	mov [rcx], rbx
    30                              <1> ;	inc rcx
    31                              <1> 	mov [digitSpacePos], rcx
    32                              <1> 
    33                              <1> %%printRAXLoop:
    34                              <1> 	mov rdx, 0
    35                              <1> 	mov rbx, 10
    36                              <1> 	div rbx
    37                              <1> 	push rax
    38                              <1> 	add rdx, 48
    39                              <1> 
    40                              <1> 	mov rcx, [digitSpacePos]
    41                              <1> 	mov [rcx], dl
    42                              <1> 	inc rcx
    43                              <1> 	mov [digitSpacePos], rcx
    44                              <1> 	
    45                              <1> 	pop rax
    46                              <1> 	cmp rax, 0
    47                              <1> 	jne %%printRAXLoop
    48                              <1> 
    49                              <1> %%printRAXLoop2:
    50                              <1> 	mov rcx, [digitSpacePos]
    51                              <1> 
    52                              <1> 	mov rax, 1
    53                              <1> 	mov rdi, 1
    54                              <1> 	mov rsi, rcx
    55                              <1> 	mov rdx, 1
    56                              <1> 	syscall
    57                              <1> 
    58                              <1> 	mov rcx, [digitSpacePos]
    59                              <1> 	dec rcx
    60                              <1> 	mov [digitSpacePos], rcx
    61                              <1> 
    62                              <1> 	cmp rcx, digitSpace
    63                              <1> 	jge %%printRAXLoop2
    64                              <1> 
    65                              <1> %endmacro
    66                              <1> 
    67                              <1> %macro exit 0
    68                              <1> 	mov rax, SYS_EXIT
    69                              <1> 	mov rdi, 0
    70                              <1> 	syscall
    71                              <1> %endmacro
    72                              <1> 
    73                              <1> STDIN_FILENO	equ	0
    74                              <1> STDOUT_FILENO	equ	1
    75                              <1> STDERR_FILENO	equ	2
    76                              <1> STDIN	equ	0
    77                              <1> STDOUT	equ	1
    78                              <1> STDERR	equ	2
    79                              <1> 
    80                              <1> O_RDONLY	equ	0
    81                              <1> O_WRONLY	equ	1
    82                              <1> O_RDWR		equ	2
    83                              <1> 
    84                              <1> O_CREAT		equ	64
    85                              <1> O_EXCL		equ	128
    86                              <1> O_NOCTTY	equ	256
    87                              <1> O_TRUNC		equ	512
    88                              <1> O_APPEND	equ	1024
    89                              <1> O_NONBLOCK	equ	2048
    90                              <1> O_NDELAY	equ	2048
    91                              <1> O_DSYNC		equ	4096
    92                              <1> O_ASYNC		equ	8192
    93                              <1> O_DIRECT	equ	16384
    94                              <1> O_DIRECTORY	equ	65536
    95                              <1> O_NOFOLLOW	equ	131072
    96                              <1> O_NOATIME	equ	262144
    97                              <1> O_CLOEXEC	equ	524288
    98                              <1> O_SYNC		equ	1052672
    99                              <1> O_PATH		equ	2097152
   100                              <1> O_TMPFILE	equ	4259840
   101                              <1> 
   102                              <1> O_LARGEFILE	equ	0
   103                              <1> 
   104                              <1> SYS_READ	equ	0
   105                              <1> SYS_WRITE	equ	1
   106                              <1> SYS_OPEN	equ	2
   107                              <1> SYS_CLOSE	equ	3
   108                              <1> SYS_STAT	equ	4
   109                              <1> SYS_FSTAT	equ	5
   110                              <1> SYS_LSTAT	equ	6
   111                              <1> SYS_POLL	equ	7
   112                              <1> SYS_LSEEK	equ	8
   113                              <1> SYS_MMAP	equ	9
   114                              <1> SYS_MPROTECT	equ	10
   115                              <1> SYS_MUNMAP	equ	11
   116                              <1> SYS_BRK	equ	12
   117                              <1> SYS_RT_SIGACTION	equ	13
   118                              <1> SYS_RT_SIGPROCMASK	equ	14
   119                              <1> SYS_RT_SIGRETURN	equ	15
   120                              <1> SYS_IOCTL	equ	16
   121                              <1> SYS_PREAD64	equ	17
   122                              <1> SYS_PWRITE64	equ	18
   123                              <1> SYS_READV	equ	19
   124                              <1> SYS_WRITEV	equ	20
   125                              <1> SYS_ACCESS	equ	21
   126                              <1> SYS_PIPE	equ	22
   127                              <1> SYS_SELECT	equ	23
   128                              <1> SYS_SCHED_YIELD	equ	24
   129                              <1> SYS_MREMAP	equ	25
   130                              <1> SYS_MSYNC	equ	26
   131                              <1> SYS_MINCORE	equ	27
   132                              <1> SYS_MADVISE	equ	28
   133                              <1> SYS_SHMGET	equ	29
   134                              <1> SYS_SHMAT	equ	30
   135                              <1> SYS_SHMCTL	equ	31
   136                              <1> SYS_DUP	equ	32
   137                              <1> SYS_DUP2	equ	33
   138                              <1> SYS_PAUSE	equ	34
   139                              <1> SYS_NANOSLEEP	equ	35
   140                              <1> SYS_GETITIMER	equ	36
   141                              <1> SYS_ALARM	equ	37
   142                              <1> SYS_SETITIMER	equ	38
   143                              <1> SYS_GETPID	equ	39
   144                              <1> SYS_SENDFILE	equ	40
   145                              <1> SYS_SOCKET	equ	41
   146                              <1> SYS_CONNECT	equ	42
   147                              <1> SYS_ACCEPT	equ	43
   148                              <1> SYS_SENDTO	equ	44
   149                              <1> SYS_RECVFROM	equ	45
   150                              <1> SYS_SENDMSG	equ	46
   151                              <1> SYS_RECVMSG	equ	47
   152                              <1> SYS_SHUTDOWN	equ	48
   153                              <1> SYS_BIND	equ	49
   154                              <1> SYS_LISTEN	equ	50
   155                              <1> SYS_GETSOCKNAME	equ	51
   156                              <1> SYS_GETPEERNAME	equ	52
   157                              <1> SYS_SOCKETPAIR	equ	53
   158                              <1> SYS_SETSOCKOPT	equ	54
   159                              <1> SYS_GETSOCKOPT	equ	55
   160                              <1> SYS_CLONE	equ	56
   161                              <1> SYS_FORK	equ	57
   162                              <1> SYS_VFORK	equ	58
   163                              <1> SYS_EXECVE	equ	59
   164                              <1> SYS_EXIT	equ	60
   165                              <1> SYS_WAIT4	equ	61
   166                              <1> SYS_KILL	equ	62
   167                              <1> SYS_UNAME	equ	63
   168                              <1> SYS_SEMGET	equ	64
   169                              <1> SYS_SEMOP	equ	65
   170                              <1> SYS_SEMCTL	equ	66
   171                              <1> SYS_SHMDT	equ	67
   172                              <1> SYS_MSGGET	equ	68
   173                              <1> SYS_MSGSND	equ	69
   174                              <1> SYS_MSGRCV	equ	70
   175                              <1> SYS_MSGCTL	equ	71
   176                              <1> SYS_FCNTL	equ	72
   177                              <1> SYS_FLOCK	equ	73
   178                              <1> SYS_FSYNC	equ	74
   179                              <1> SYS_FDATASYNC	equ	75
   180                              <1> SYS_TRUNCATE	equ	76
   181                              <1> SYS_FTRUNCATE	equ	77
   182                              <1> SYS_GETDENTS	equ	78
   183                              <1> SYS_GETCWD	equ	79
   184                              <1> SYS_CHDIR	equ	80
   185                              <1> SYS_FCHDIR	equ	81
   186                              <1> SYS_RENAME	equ	82
   187                              <1> SYS_MKDIR	equ	83
   188                              <1> SYS_RMDIR	equ	84
   189                              <1> SYS_CREAT	equ	85
   190                              <1> SYS_LINK	equ	86
   191                              <1> SYS_UNLINK	equ	87
   192                              <1> SYS_SYMLINK	equ	88
   193                              <1> SYS_READLINK	equ	89
   194                              <1> SYS_CHMOD	equ	90
   195                              <1> SYS_FCHMOD	equ	91
   196                              <1> SYS_CHOWN	equ	92
   197                              <1> SYS_FCHOWN	equ	93
   198                              <1> SYS_LCHOWN	equ	94
   199                              <1> SYS_UMASK	equ	95
   200                              <1> SYS_GETTIMEOFDAY	equ	96
   201                              <1> SYS_GETRLIMIT	equ	97
   202                              <1> SYS_GETRUSAGE	equ	98
   203                              <1> SYS_SYSINFO	equ	99
   204                              <1> SYS_TIMES	equ	100
   205                              <1> SYS_PTRACE	equ	101
   206                              <1> SYS_GETUID	equ	102
   207                              <1> SYS_SYSLOG	equ	103
   208                              <1> SYS_GETGID	equ	104
   209                              <1> SYS_SETUID	equ	105
   210                              <1> SYS_SETGID	equ	106
   211                              <1> SYS_GETEUID	equ	107
   212                              <1> SYS_GETEGID	equ	108
   213                              <1> SYS_SETPGID	equ	109
   214                              <1> SYS_GETPPID	equ	110
   215                              <1> SYS_GETPGRP	equ	111
   216                              <1> SYS_SETSID	equ	112
   217                              <1> SYS_SETREUID	equ	113
   218                              <1> SYS_SETREGID	equ	114
   219                              <1> SYS_GETGROUPS	equ	115
   220                              <1> SYS_SETGROUPS	equ	116
   221                              <1> SYS_SETRESUID	equ	117
   222                              <1> SYS_GETRESUID	equ	118
   223                              <1> SYS_SETRESGID	equ	119
   224                              <1> SYS_GETRESGID	equ	120
   225                              <1> SYS_GETPGID	equ	121
   226                              <1> SYS_SETFSUID	equ	122
   227                              <1> SYS_SETFSGID	equ	123
   228                              <1> SYS_GETSID	equ	124
   229                              <1> SYS_CAPGET	equ	125
   230                              <1> SYS_CAPSET	equ	126
   231                              <1> SYS_RT_SIGPENDING	equ	127
   232                              <1> SYS_RT_SIGTIMEDWAIT	equ	128
   233                              <1> SYS_RT_SIGQUEUEINFO	equ	129
   234                              <1> SYS_RT_SIGSUSPEND	equ	130
   235                              <1> SYS_SIGALTSTACK	equ	131
   236                              <1> SYS_UTIME	equ	132
   237                              <1> SYS_MKNOD	equ	133
   238                              <1> SYS_USELIB	equ	134
   239                              <1> SYS_PERSONALITY	equ	135
   240                              <1> SYS_USTAT	equ	136
   241                              <1> SYS_STATFS	equ	137
   242                              <1> SYS_FSTATFS	equ	138
   243                              <1> SYS_SYSFS	equ	139
   244                              <1> SYS_GETPRIORITY	equ	140
   245                              <1> SYS_SETPRIORITY	equ	141
   246                              <1> SYS_SCHED_SETPARAM	equ	142
   247                              <1> SYS_SCHED_GETPARAM	equ	143
   248                              <1> SYS_SCHED_SETSCHEDULER	equ	144
   249                              <1> SYS_SCHED_GETSCHEDULER	equ	145
   250                              <1> SYS_SCHED_GET_PRIORITY_MAX	equ	146
   251                              <1> SYS_SCHED_GET_PRIORITY_MIN	equ	147
   252                              <1> SYS_SCHED_RR_GET_INTERVAL	equ	148
   253                              <1> SYS_MLOCK	equ	149
   254                              <1> SYS_MUNLOCK	equ	150
   255                              <1> SYS_MLOCKALL	equ	151
   256                              <1> SYS_MUNLOCKALL	equ	152
   257                              <1> SYS_VHANGUP	equ	153
   258                              <1> SYS_MODIFY_LDT	equ	154
   259                              <1> SYS_PIVOT_ROOT	equ	155
   260                              <1> SYS__SYSCTL	equ	156
   261                              <1> SYS_PRCTL	equ	157
   262                              <1> SYS_ARCH_PRCTL	equ	158
   263                              <1> SYS_ADJTIMEX	equ	159
   264                              <1> SYS_SETRLIMIT	equ	160
   265                              <1> SYS_CHROOT	equ	161
   266                              <1> SYS_SYNC	equ	162
   267                              <1> SYS_ACCT	equ	163
   268                              <1> SYS_SETTIMEOFDAY	equ	164
   269                              <1> SYS_MOUNT	equ	165
   270                              <1> SYS_UMOUNT2	equ	166
   271                              <1> SYS_SWAPON	equ	167
   272                              <1> SYS_SWAPOFF	equ	168
   273                              <1> SYS_REBOOT	equ	169
   274                              <1> SYS_SETHOSTNAME	equ	170
   275                              <1> SYS_SETDOMAINNAME	equ	171
   276                              <1> SYS_IOPL	equ	172
   277                              <1> SYS_IOPERM	equ	173
   278                              <1> SYS_CREATE_MODULE	equ	174
   279                              <1> SYS_INIT_MODULE	equ	175
   280                              <1> SYS_DELETE_MODULE	equ	176
   281                              <1> SYS_GET_KERNEL_SYMS	equ	177
   282                              <1> SYS_QUERY_MODULE	equ	178
   283                              <1> SYS_QUOTACTL	equ	179
   284                              <1> SYS_NFSSERVCTL	equ	180
   285                              <1> SYS_GETPMSG	equ	181
   286                              <1> SYS_PUTPMSG	equ	182
   287                              <1> SYS_AFS_SYSCALL	equ	183
   288                              <1> SYS_TUXCALL	equ	184
   289                              <1> SYS_SECURITY	equ	185
   290                              <1> SYS_GETTID	equ	186
   291                              <1> SYS_READAHEAD	equ	187
   292                              <1> SYS_SETXATTR	equ	188
   293                              <1> SYS_LSETXATTR	equ	189
   294                              <1> SYS_FSETXATTR	equ	190
   295                              <1> SYS_GETXATTR	equ	191
   296                              <1> SYS_LGETXATTR	equ	192
   297                              <1> SYS_FGETXATTR	equ	193
   298                              <1> SYS_LISTXATTR	equ	194
   299                              <1> SYS_LLISTXATTR	equ	195
   300                              <1> SYS_FLISTXATTR	equ	196
   301                              <1> SYS_REMOVEXATTR	equ	197
   302                              <1> SYS_LREMOVEXATTR	equ	198
   303                              <1> SYS_FREMOVEXATTR	equ	199
   304                              <1> SYS_TKILL	equ	200
   305                              <1> SYS_TIME	equ	201
   306                              <1> SYS_FUTEX	equ	202
   307                              <1> SYS_SCHED_SETAFFINITY	equ	203
   308                              <1> SYS_SCHED_GETAFFINITY	equ	204
   309                              <1> SYS_SET_THREAD_AREA	equ	205
   310                              <1> SYS_IO_SETUP	equ	206
   311                              <1> SYS_IO_DESTROY	equ	207
   312                              <1> SYS_IO_GETEVENTS	equ	208
   313                              <1> SYS_IO_SUBMIT	equ	209
   314                              <1> SYS_IO_CANCEL	equ	210
   315                              <1> SYS_GET_THREAD_AREA	equ	211
   316                              <1> SYS_LOOKUP_DCOOKIE	equ	212
   317                              <1> SYS_EPOLL_CREATE	equ	213
   318                              <1> SYS_EPOLL_CTL_OLD	equ	214
   319                              <1> SYS_EPOLL_WAIT_OLD	equ	215
   320                              <1> SYS_REMAP_FILE_PAGES	equ	216
   321                              <1> SYS_GETDENTS64	equ	217
   322                              <1> SYS_SET_TID_ADDRESS	equ	218
   323                              <1> SYS_RESTART_SYSCALL	equ	219
   324                              <1> SYS_SEMTIMEDOP	equ	220
   325                              <1> SYS_FADVISE64	equ	221
   326                              <1> SYS_TIMER_CREATE	equ	222
   327                              <1> SYS_TIMER_SETTIME	equ	223
   328                              <1> SYS_TIMER_GETTIME	equ	224
   329                              <1> SYS_TIMER_GETOVERRUN	equ	225
   330                              <1> SYS_TIMER_DELETE	equ	226
   331                              <1> SYS_CLOCK_SETTIME	equ	227
   332                              <1> SYS_CLOCK_GETTIME	equ	228
   333                              <1> SYS_CLOCK_GETRES	equ	229
   334                              <1> SYS_CLOCK_NANOSLEEP	equ	230
   335                              <1> SYS_EXIT_GROUP	equ	231
   336                              <1> SYS_EPOLL_WAIT	equ	232
   337                              <1> SYS_EPOLL_CTL	equ	233
   338                              <1> SYS_TGKILL	equ	234
   339                              <1> SYS_UTIMES	equ	235
   340                              <1> SYS_VSERVER	equ	236
   341                              <1> SYS_MBIND	equ	237
   342                              <1> SYS_SET_MEMPOLICY	equ	238
   343                              <1> SYS_GET_MEMPOLICY	equ	239
   344                              <1> SYS_MQ_OPEN	equ	240
   345                              <1> SYS_MQ_UNLINK	equ	241
   346                              <1> SYS_MQ_TIMEDSEND	equ	242
   347                              <1> SYS_MQ_TIMEDRECEIVE	equ	243
   348                              <1> SYS_MQ_NOTIFY	equ	244
   349                              <1> SYS_MQ_GETSETATTR	equ	245
   350                              <1> SYS_KEXEC_LOAD	equ	246
   351                              <1> SYS_WAITID	equ	247
   352                              <1> SYS_ADD_KEY	equ	248
   353                              <1> SYS_REQUEST_KEY	equ	249
   354                              <1> SYS_KEYCTL	equ	250
   355                              <1> SYS_IOPRIO_SET	equ	251
   356                              <1> SYS_IOPRIO_GET	equ	252
   357                              <1> SYS_INOTIFY_INIT	equ	253
   358                              <1> SYS_INOTIFY_ADD_WATCH	equ	254
   359                              <1> SYS_INOTIFY_RM_WATCH	equ	255
   360                              <1> SYS_MIGRATE_PAGES	equ	256
   361                              <1> SYS_OPENAT	equ	257
   362                              <1> SYS_MKDIRAT	equ	258
   363                              <1> SYS_MKNODAT	equ	259
   364                              <1> SYS_FCHOWNAT	equ	260
   365                              <1> SYS_FUTIMESAT	equ	261
   366                              <1> SYS_NEWFSTATAT	equ	262
   367                              <1> SYS_UNLINKAT	equ	263
   368                              <1> SYS_RENAMEAT	equ	264
   369                              <1> SYS_LINKAT	equ	265
   370                              <1> SYS_SYMLINKAT	equ	266
   371                              <1> SYS_READLINKAT	equ	267
   372                              <1> SYS_FCHMODAT	equ	268
   373                              <1> SYS_FACCESSAT	equ	269
   374                              <1> SYS_PSELECT6	equ	270
   375                              <1> SYS_PPOLL	equ	271
   376                              <1> SYS_UNSHARE	equ	272
   377                              <1> SYS_SET_ROBUST_LIST	equ	273
   378                              <1> SYS_GET_ROBUST_LIST	equ	274
   379                              <1> SYS_SPLICE	equ	275
   380                              <1> SYS_TEE	equ	276
   381                              <1> SYS_SYNC_FILE_RANGE	equ	277
   382                              <1> SYS_VMSPLICE	equ	278
   383                              <1> SYS_MOVE_PAGES	equ	279
   384                              <1> SYS_UTIMENSAT	equ	280
   385                              <1> SYS_EPOLL_PWAIT	equ	281
   386                              <1> SYS_SIGNALFD	equ	282
   387                              <1> SYS_TIMERFD_CREATE	equ	283
   388                              <1> SYS_EVENTFD	equ	284
   389                              <1> SYS_FALLOCATE	equ	285
   390                              <1> SYS_TIMERFD_SETTIME	equ	286
   391                              <1> SYS_TIMERFD_GETTIME	equ	287
   392                              <1> SYS_ACCEPT4	equ	288
   393                              <1> SYS_SIGNALFD4	equ	289
   394                              <1> SYS_EVENTFD2	equ	290
   395                              <1> SYS_EPOLL_CREATE1	equ	291
   396                              <1> SYS_DUP3	equ	292
   397                              <1> SYS_PIPE2	equ	293
   398                              <1> SYS_INOTIFY_INIT1	equ	294
   399                              <1> SYS_PREADV	equ	295
   400                              <1> SYS_PWRITEV	equ	296
   401                              <1> SYS_RT_TGSIGQUEUEINFO	equ	297
   402                              <1> SYS_PERF_EVENT_OPEN	equ	298
   403                              <1> SYS_RECVMMSG	equ	299
   404                              <1> SYS_FANOTIFY_INIT	equ	300
   405                              <1> SYS_FANOTIFY_MARK	equ	301
   406                              <1> SYS_PRLIMIT64	equ	302
   407                              <1> SYS_NAME_TO_HANDLE_AT	equ	303
   408                              <1> SYS_OPEN_BY_HANDLE_AT	equ	304
   409                              <1> SYS_CLOCK_ADJTIME	equ	305
   410                              <1> SYS_SYNCFS	equ	306
   411                              <1> SYS_SENDMMSG	equ	307
   412                              <1> SYS_SETNS	equ	308
   413                              <1> SYS_GETCPU	equ	309
   414                              <1> SYS_PROCESS_VM_READV	equ	310
   415                              <1> SYS_PROCESS_VM_WRITEV	equ	311
   416                              <1> SYS_KCMP	equ	312
   417                              <1> SYS_FINIT_MODULE	equ	313
   418                              <1> SYS_SCHED_SETATTR	equ	314
   419                              <1> SYS_SCHED_GETATTR	equ	315
   420                              <1> SYS_RENAMEAT2	equ	316
   421                              <1> SYS_SECCOMP	equ	317
   422                              <1> SYS_GETRANDOM	equ	318
   423                              <1> SYS_MEMFD_CREATE	equ	319
   424                              <1> SYS_KEXEC_FILE_LOAD	equ	320
   425                              <1> SYS_BPF	equ	321
   426                              <1> STUB_EXECVEAT	equ	322
   427                              <1> USERFAULTFD	equ	323
   428                              <1> MEMBARRIER	equ	324
   429                              <1> MLOCK2	equ	325
   430                              <1> COPY_FILE_RANGE	equ	326
   431                              <1> PREADV2	equ	327
   432                              <1> PWRITEV2	equ	328
     2                                  
     3                                  DEFAULT REL
     4                                  global movePiece
     5                                  global outputBoard
     6                                  extern printf
     7                                  
     8                                  %macro _startCoords 0 ;// translates the coordinates in startRow and startCol to [rBx][rCx] fo easy acess.
     9                                  
    10                                                  mov     rAx, [startRow]               ;// convert startRow coord into bytes
    11                                                  mov     rBx, 8
    12                                                  mul     rBx
    13                                  
    14                                                  mov     rBx, [checkerboard+rAx]      ;// move the target row into rBx
    15                                                  mov     rCx, [startCol]
    16                                  
    17                                  %endmacro
    18                                  
    19                                  %macro _endCoords 0 ;// translates the coordinates in endRow and endCol to [rBx][rCx] fo easy acess.
    20                                  
    21                                                  mov     rAx, [endRow]                 ;// convert endRow coord into bytes
    22                                                  mov     rBx, 8
    23                                                  mul     rBx
    24                                  
    25                                                  mov     rBx, [checkerboard+rAx]      ;// move the target tow into rBx
    26                                                  mov     rCx, [endCol]
    27                                  
    28                                  %endmacro
    29                                  
    30                                  SECTION .data
    31                                  
    32                                  ; leftB db "[ ",0
    33                                  ; rightB db " ]",0
    34                                  
    35 00000000 0200020002000200        row0 db 2, 0, 2, 0, 2, 0, 2, 0
    36 00000008 0002000200020002        row1 db 0, 2, 0, 2, 0, 2, 0, 2
    37 00000010 0200020002000200        row2 db 2, 0, 2, 0, 2, 0, 2, 0
    38 00000018 0000000000000000        row3 db 0, 0, 0, 0, 0, 0, 0, 0
    39 00000020 0000000000000000        row4 db 0, 0, 0, 0, 0, 0, 0, 0
    40 00000028 0001000100010001        row5 db 0, 1, 0, 1, 0, 1, 0, 1
    41 00000030 0100010001000100        row6 db 1, 0, 1, 0, 1, 0, 1, 0
    42 00000038 0001000100010001        row7 db 0, 1, 0, 1, 0, 1, 0, 1
    43                                  
    44 00000040 436865636B6572626F-     filename db "Checkerboard.txt",0
    44 00000049 6172642E74787400   
    45                                  
    46 00000051 [0000000000000000]-     checkerboard dq row0, row1, row2, row3, row4, row5, row6, row7
    46 00000059 [0800000000000000]-
    46 00000061 [1000000000000000]-
    46 00000069 [1800000000000000]-
    46 00000071 [2000000000000000]-
    46 00000079 [2800000000000000]-
    46 00000081 [3000000000000000]-
    46 00000089 [3800000000000000] 
    47                                  
    48 00000091 4A4F53484445425547-     message db "JOSHDEBUG = %d", 10, 0
    48 0000009A 203D2025640A00     
    49                                  
    50                                  SECTION .bss
    51                                  itemToAdd:
    52 00000074 <res 00000010>            RESB 16
    53                                  fileDescriptor:
    54 00000084 <res 00000010>            RESB 16
    55                                  startRow: 
    56 00000094 <res 00000100>            RESB 256
    57                                  startCol:
    58 00000194 <res 00000100>            RESB 256
    59                                  endRow:
    60 00000294 <res 00000100>            RESB 256
    61                                  endCol:
    62 00000394 <res 00000100>            RESB 256
    63                                       
    64                                  
    65                                  SECTION .text
    66                                  
    67                                  outputBoard:
    68 00000000 B802000000                                      mov rax, SYS_OPEN
    69 00000005 48BF-                   	                mov rdi, filename
    69 00000007 [4000000000000000] 
    70 0000000F BE41000000              	                mov rsi, O_CREAT+O_WRONLY
    71 00000014 BAA4010000              	                mov rdx, 0644o
    72 00000019 0F05                    	                syscall
    73 0000001B 488905(84000000)        	                mov [fileDescriptor], rax
    74                                  
    75 00000022 4831C9                                      xor     rCx, rCx                        ;// int i = 0
    76 00000025 4883F940                    FOR_outB:       cmp     rCx, 64                         ;// for i < 32
    77 00000029 7C02                                        jl      DOFOR_outB
    78 0000002B EB14                                        jmp     ENDFOR_outB
    79                                  
    80 0000002D 488B99[51000000]            DOFOR_outB:     mov     rBx, [checkerboard+rCx]          ;//puts row[rCx] into rBx for outputRow Function
    81 00000034 51                                          push    rCx
    82 00000035 E816000000                                  call    outputRow
    83 0000003A 59                                          pop     rCx
    84 0000003B 4883C108                                    add     rCx, 8                          ;// i+=4
    85                                  
    86 0000003F EBE4                                        jmp     FOR_outB
    87                                      ENDFOR_outB:   
    88 00000041 B803000000                                  mov rax, SYS_CLOSE
    89 00000046 488B3D(84000000)        	            mov rdi, [fileDescriptor]
    90 0000004D 0F05                    	            syscall
    91 0000004F C3                                          ret
    92                                  
    93                                  
    94                                  outputRow:                                              ;// Requires: rBx =  rowX
    95 00000050 4831C9                                      xor     rCx, rCx                        ;// int j = 0
    96 00000053 4883F908                    FOR_outR:       cmp     rCx, 8                          ;// for j < 8
    97 00000057 7C02                                        jl      DOFOR_outR
    98 00000059 EB37                                        jmp     ENDFOR_outR
    99                                  
   100                                      DOFOR_outR:     
   101 0000005B 4831C0                                      xor     rAx, rAx                        ;// clear rAx
   102 0000005E 8A040B                                      mov     Al, [rBx + rCx]                 ;// VVV
   103 00000061 488B3D(84000000)        			mov rdi, [fileDescriptor]
   104 00000068 4883C030                			add rax, 48
   105 0000006C B420                    			mov ah, 32                          ;// Adds a space between the numbers in the file.
   106 0000006E 488905(74000000)        			mov [itemToAdd], rax
   107 00000075 48BE-                   	                mov rsi, itemToAdd
   107 00000077 [7400000000000000] 
   108 0000007F B801000000              	                mov rax, SYS_WRITE
   109 00000084 BA02000000              	                mov rdx, 2
   110 00000089 51                      			push rcx
   111 0000008A 0F05                    	                syscall
   112 0000008C 59                      			pop rcx
   113 0000008D 48FFC1                                      inc rcx
   114 00000090 EBC1                                        jmp     FOR_outR
   115                                  
   116                                      ENDFOR_outR:     
   117 00000092 C3                                          ret
   118                                  
   119                                  movePiece:
   120                                  
   121 00000093 893D(94000000)                mov [startRow], edi
   122 00000099 8935(94010000)                mov [startCol], esi
   123 0000009F 8915(94020000)                mov [endRow], edx
   124 000000A5 890D(94030000)                mov [endCol], ecx
   125                                  
   126                                  strt_OOB_test:
   127 000000AB 833D(94000000)00                            cmp     [startRow], DWORD 0
   128 000000B2 0F8C03040000                                jl      END_MOVE
   129 000000B8 833D(94000000)07                            cmp     [startRow], DWORD 7
   130 000000BF 0F8FF6030000                                jg      END_MOVE
   131 000000C5 833D(94010000)00                            cmp     [startCol], DWORD 0
   132 000000CC 0F8CE9030000                                jl      END_MOVE
   133 000000D2 833D(94010000)07                            cmp     [startCol], DWORD 7
   134 000000D9 0F8FDC030000                                jg      END_MOVE
   135                                  
   136                                                      ;// ILLEGAL MOVE: destination square out of bounds
   137                                  dst_OOB_test:
   138 000000DF 833D(94020000)00                            cmp     [endRow], DWORD 0
   139 000000E6 0F8CCF030000                                jl      END_MOVE
   140 000000EC 833D(94020000)07                            cmp     [endRow], DWORD 7
   141 000000F3 0F8FC2030000                                jg      END_MOVE
   142 000000F9 833D(94030000)00                            cmp     [endCol], DWORD 0
   143 00000100 0F8CB5030000                                jl      END_MOVE
   144 00000106 833D(94030000)07                            cmp     [endCol], DWORD 7
   145 0000010D 0F8FA8030000                                jg      END_MOVE
   146                                  
   147                                                      ;// ILLEGAL MOVE: destination square is black
   148                                  dst_BLK_test:
   149 00000113 488B05(94020000)                            mov     rAx, [endRow]
   150 0000011A 480305(94030000)                            add     rAx, [endCol]
   151 00000121 4831D2                                      xor     rDx, rDx
   152 00000124 BB02000000                                  mov     rBx, 2                       ;// divide the sum of the coords by 2
   153 00000129 48F7F3                                      div     rBx                          ;// since all white spaces contain either two od coords or two even coords, then the sum must be even
   154 0000012C 4883FA01                                    cmp     rDx, 1                      ;// if the remanider of div 2 is 1, then the destination square must be black
   155 00000130 0F8485030000                                je      END_MOVE
   156                                  
   157                                                      ;// ILLEGAL MOVE: destination square is backwards (or if the starting square is rmpty)
   158                                  dst_BACK_test:
   159                                                      _startCoords
   159                              <1> 
   159 00000136 488B05(94000000)    <1>  mov rAx, [startRow]
   159 0000013D BB08000000          <1>  mov rBx, 8
   159 00000142 48F7E3              <1>  mul rBx
   159                              <1> 
   159 00000145 488B98[51000000]    <1>  mov rBx, [checkerboard+rAx]
   159 0000014C 488B0D(94010000)    <1>  mov rCx, [startCol]
   159                              <1> 
   160 00000153 8A040B                                      mov     AL, [rBx + rCx]
   161 00000156 3C03                                        cmp     AL, 3
   162 00000158 7463                                        je      ENDIF_P12
   163 0000015A 3C04                                        cmp     AL, 4
   164 0000015C 745F                                        je      ENDIF_P12
   165 0000015E 3C02                        IF_P2:          cmp     AL, 2                       ;// if thr piece at the startCoords is a 2 (black piece)
   166 00000160 7402                                        je      THEN_P2
   167 00000162 EB39                                        jmp     IF_P1
   168 00000164 488B05(94000000)                THEN_P2:    mov     rAx, [startRow]               ;// then thr piece can only move down the board (positivr x)
   169 0000016B 48FFC0                                      inc     rAx
   170 0000016E 483B05(94020000)                            cmp     rAx, [endRow]
   171 00000175 0F8540030000                                jne     END_MOVE
   172 0000017B EB40                                        jmp     ENDIF_P12
   173                                  
   174                                                      _startCoords
   174                              <1> 
   174 0000017D 488B05(94000000)    <1>  mov rAx, [startRow]
   174 00000184 BB08000000          <1>  mov rBx, 8
   174 00000189 48F7E3              <1>  mul rBx
   174                              <1> 
   174 0000018C 488B98[51000000]    <1>  mov rBx, [checkerboard+rAx]
   174 00000193 488B0D(94010000)    <1>  mov rCx, [startCol]
   174                              <1> 
   175 0000019A 8A040B                                      mov     AL, [rBx + rCx]
   176 0000019D 3C01                        IF_P1:          cmp     AL, 1                       ;// if thr piece at the startCoords is a 1 (red piece)
   177 0000019F 7405                                        je      THEN_P1
   178 000001A1 E915030000                                  jmp     END_MOVE                 ;// if thr piece is neither a 1 nor a two, it cannot be moved
   179 000001A6 488B05(94000000)                THEN_P1:    mov     rAx, [startRow]               ;// then thr piece can only move down the board (positivr x)
   180 000001AD 48FFC8                                      dec     rAx
   181 000001B0 483B05(94020000)                            cmp     rAx, [endRow]
   182 000001B7 0F85FE020000                                jne     END_MOVE
   183                                  
   184                                      ENDIF_P12:
   185                                  
   186                                                      ;// ILLEGAL MOVE: destination square is occupied (also if the start space is rmpty)
   187                                  dst_OCP_test:
   188                                                      _startCoords
   188                              <1> 
   188 000001BD 488B05(94000000)    <1>  mov rAx, [startRow]
   188 000001C4 BB08000000          <1>  mov rBx, 8
   188 000001C9 48F7E3              <1>  mul rBx
   188                              <1> 
   188 000001CC 488B98[51000000]    <1>  mov rBx, [checkerboard+rAx]
   188 000001D3 488B0D(94010000)    <1>  mov rCx, [startCol]
   188                              <1> 
   189 000001DA 8A040B                                      mov     AL, [rBx + rCx]
   190 000001DD 3C02                        IF_O2           cmp     AL, 2                       ;// if thr piece at the start is a 2 (black piece)
   191 000001DF 7406                                        je      THEN_O2
   192 000001E1 3C04                                        cmp     AL, 4
   193 000001E3 7402                                        je      THEN_O2
   194 000001E5 EB32                                        jmp     IF_O1
   195                                          THEN_O2:    _endCoords                          ;// then it cannot jump a friendly piece
   195                              <1>  THEN_O2: 
   195                              <1> 
   195 000001E7 488B05(94020000)    <1>  mov rAx, [endRow]
   195 000001EE BB08000000          <1>  mov rBx, 8
   195 000001F3 48F7E3              <1>  mul rBx
   195                              <1> 
   195 000001F6 488B98[51000000]    <1>  mov rBx, [checkerboard+rAx]
   195 000001FD 488B0D(94030000)    <1>  mov rCx, [endCol]
   195                              <1> 
   196 00000204 8A040B                                      mov     AL, [rBx + rCx]
   197 00000207 3C02                                        cmp     Al, 2
   198 00000209 0F84AC020000                                je      END_MOVE
   199 0000020F 3C04                                        cmp     Al, 4
   200 00000211 0F84A4020000                                je      END_MOVE
   201 00000217 EB5A                                        jmp     ENDIF_O12
   202                                  
   203                                      IF_O1:          _startCoords
   203                              <1>  IF_O1: 
   203                              <1> 
   203 00000219 488B05(94000000)    <1>  mov rAx, [startRow]
   203 00000220 BB08000000          <1>  mov rBx, 8
   203 00000225 48F7E3              <1>  mul rBx
   203                              <1> 
   203 00000228 488B98[51000000]    <1>  mov rBx, [checkerboard+rAx]
   203 0000022F 488B0D(94010000)    <1>  mov rCx, [startCol]
   203                              <1> 
   204 00000236 8A040B                                      mov     AL, [rBx + rCx]
   205 00000239 3C01                                        cmp     AL, 1                       ;// if thr piece at the start is a 1 (red piece)
   206 0000023B 7406                                        je      THEN_O1
   207 0000023D 3C03                                        cmp     AL, 3
   208 0000023F 7402                                        je      THEN_O1
   209 00000241 EB30                                        jmp     ENDIF_O12
   210                                          THEN_O1:    _endCoords
   210                              <1>  THEN_O1: 
   210                              <1> 
   210 00000243 488B05(94020000)    <1>  mov rAx, [endRow]
   210 0000024A BB08000000          <1>  mov rBx, 8
   210 0000024F 48F7E3              <1>  mul rBx
   210                              <1> 
   210 00000252 488B98[51000000]    <1>  mov rBx, [checkerboard+rAx]
   210 00000259 488B0D(94030000)    <1>  mov rCx, [endCol]
   210                              <1> 
   211 00000260 8A040B                                      mov     AL, [rBx + rCx]
   212 00000263 3C01                                        cmp     AL, 1                       ;// then it cannot jump a friendly piece
   213 00000265 0F8450020000                                je      END_MOVE
   214 0000026B 3C03                                        cmp     AL, 3
   215 0000026D 0F8448020000                                je      END_MOVE
   216                                  
   217                                      ENDIF_O12:
   218                                  
   219                                                      ;// Testing for attrmpted jump
   220                                  jmp_test:
   221                                                      _startCoords
   221                              <1> 
   221 00000273 488B05(94000000)    <1>  mov rAx, [startRow]
   221 0000027A BB08000000          <1>  mov rBx, 8
   221 0000027F 48F7E3              <1>  mul rBx
   221                              <1> 
   221 00000282 488B98[51000000]    <1>  mov rBx, [checkerboard+rAx]
   221 00000289 488B0D(94010000)    <1>  mov rCx, [startCol]
   221                              <1> 
   222 00000290 8A040B                                      mov     AL, [rBx + rCx]
   223 00000293 3C02                        IF_J2:          cmp     AL, 2                       ;// if the piece at the start is a 2 (black piece)
   224 00000295 7406                                        je      THEN_J2
   225 00000297 3C04                                        cmp     AL, 4
   226 00000299 7402                                        je      THEN_J2
   227 0000029B EB2D                                        jmp     IF_J1
   228                                          THEN_J2:    _endCoords                          ;// and the dest contains an enemy piece
   228                              <1>  THEN_J2: 
   228                              <1> 
   228 0000029D 488B05(94020000)    <1>  mov rAx, [endRow]
   228 000002A4 BB08000000          <1>  mov rBx, 8
   228 000002A9 48F7E3              <1>  mul rBx
   228                              <1> 
   228 000002AC 488B98[51000000]    <1>  mov rBx, [checkerboard+rAx]
   228 000002B3 488B0D(94030000)    <1>  mov rCx, [endCol]
   228                              <1> 
   229 000002BA 8A040B                                      mov     AL, [rBx + rCx]
   230 000002BD 3C01                                        cmp     Al, 1
   231 000002BF 7460                                        je      ENDIF_J12                   ;// check for illegal jump
   232 000002C1 3C03                                        cmp     AL, 3
   233 000002C3 745C                                        je      ENDIF_J12
   234 000002C5 E90B010000                                  jmp     legal_move                  ;// otherwise, just move normally
   235                                  
   236                                      IF_J1:          _startCoords
   236                              <1>  IF_J1: 
   236                              <1> 
   236 000002CA 488B05(94000000)    <1>  mov rAx, [startRow]
   236 000002D1 BB08000000          <1>  mov rBx, 8
   236 000002D6 48F7E3              <1>  mul rBx
   236                              <1> 
   236 000002D9 488B98[51000000]    <1>  mov rBx, [checkerboard+rAx]
   236 000002E0 488B0D(94010000)    <1>  mov rCx, [startCol]
   236                              <1> 
   237 000002E7 8A040B                                      mov     AL, [rBx + rCx]
   238 000002EA 3C01                                        cmp     AL, 1                       ;// if thr piece at the start is a 1 (red piece)
   239 000002EC 7406                                        je      THEN_J1
   240 000002EE 3C03                                        cmp     AL, 3
   241 000002F0 7402                                        je      THEN_J1
   242 000002F2 EB2D                                        jmp     ENDIF_J12
   243                                          THEN_J1:    _endCoords                          ;// and the dest contains an enemy piece
   243                              <1>  THEN_J1: 
   243                              <1> 
   243 000002F4 488B05(94020000)    <1>  mov rAx, [endRow]
   243 000002FB BB08000000          <1>  mov rBx, 8
   243 00000300 48F7E3              <1>  mul rBx
   243                              <1> 
   243 00000303 488B98[51000000]    <1>  mov rBx, [checkerboard+rAx]
   243 0000030A 488B0D(94030000)    <1>  mov rCx, [endCol]
   243                              <1> 
   244 00000311 8A040B                                      mov     Al, [rBx + rCx]
   245 00000314 3C02                                        cmp     AL, 2
   246 00000316 7409                                        je      ENDIF_J12                   ;// check for illegal jump
   247 00000318 3C04                                        cmp     AL, 4
   248 0000031A 7405                                        je      ENDIF_J12
   249 0000031C E9B4000000                                  jmp     legal_move                  ;// otherwise, just move normally
   250                                  
   251                                      ENDIF_J12:
   252                                  
   253                                                      ;// ILLEGAL MOVE: jump is out of bounds
   254                                  jmp_OOB_test:
   255 00000321 488B05(94020000)                            mov     rAx, [endRow]                     ;//converts inout endCoords to proper jump destination
   256 00000328 482B05(94000000)                            sub     rAx, [startRow]
   257 0000032F BB02000000                                  mov     rBx, 2
   258 00000334 48F7EB                                      imul    rBx
   259 00000337 480305(94000000)                            add     rAx, [startRow]
   260                                  
   261 0000033E 4883F800                                    cmp     rAx, 0
   262 00000342 0F8C73010000                                jl      END_MOVE
   263 00000348 4883F807                                    cmp     rAx, 7
   264 0000034C 0F8F69010000                                jg      END_MOVE
   265                                  
   266 00000352 488B05(94030000)                            mov     rAx, [endCol]                     ;//converts inout endCoords to proper jump destination
   267 00000359 482B05(94010000)                            sub     rAx, [startCol]
   268 00000360 B902000000                                  mov     rCx, 2
   269 00000365 48F7E9                                      imul     rCx
   270 00000368 480305(94010000)                            add     rAx, [startCol]
   271                                  
   272 0000036F 4883F800                                    cmp     rAx, 0
   273 00000373 0F8C42010000                                jl      END_MOVE
   274 00000379 4883F807                                    cmp     rAx, 7
   275 0000037D 0F8F38010000                                jg      END_MOVE
   276                                  
   277                                                      ;// ILLEGAL MOVE: jump destination is occupied
   278                                  jmp_OCP_test:
   279 00000383 488B05(94020000)                            mov     rAx, [endRow]                     ;//converts inout endCoords to proper jump destination
   280 0000038A 482B05(94000000)                            sub     rAx, [startRow]
   281 00000391 BB02000000                                  mov     rBx, 2
   282 00000396 48F7EB                                      imul    rBx
   283 00000399 480305(94000000)                            add     rAx, [startRow]
   284 000003A0 488B1CC5[51000000]                          mov     rBx, [checkerboard+8*rAx]
   285                                  
   286 000003A8 488B05(94030000)                            mov     rAx, [endCol]                     ;//converts inout endCoords to proper jump destination
   287 000003AF 482B05(94010000)                            sub     rAx, [startCol]
   288 000003B6 B902000000                                  mov     rCx, 2
   289 000003BB 48F7E9                                      imul    rCx
   290 000003BE 480305(94010000)                            add     rAx, [startCol]
   291 000003C5 4889C1                                      mov     rCx, rAx
   292                                  
   293 000003C8 66833C0B00                                  cmp     [rBx + rCx], WORD 0
   294 000003CD 0F85E8000000                                jne     END_MOVE
   295 000003D3 EB50                                        jmp     legal_jump
   296                                  
   297                                                      ;// LEGAL MOVE OR JUMP:
   298                                  legal_move:
   299                                                      _startCoords                            ;// puts startRow and startCol into [rBx][rCx]
   299                              <1> 
   299 000003D5 488B05(94000000)    <1>  mov rAx, [startRow]
   299 000003DC BB08000000          <1>  mov rBx, 8
   299 000003E1 48F7E3              <1>  mul rBx
   299                              <1> 
   299 000003E4 488B98[51000000]    <1>  mov rBx, [checkerboard+rAx]
   299 000003EB 488B0D(94010000)    <1>  mov rCx, [startCol]
   299                              <1> 
   300 000003F2 4831C0                                      xor     rAx, rAx
   301 000003F5 8A040B                                      mov     AL, [rBx + rCx]                  ;// move the value at [startRow][startCol] into AL
   302 000003F8 50                                          push    rAx                             ;// save thr piece to be moved
   303                                  
   304 000003F9 4831C0                                      xor     rAx, rAx
   305 000003FC 88040B                                      mov     [rBx + rCx], AL                  ;// rmpty the space
   306                                  
   307                                                      _endCoords                              ;// puts endRow and endCol into [rBx][rCx]
   307                              <1> 
   307 000003FF 488B05(94020000)    <1>  mov rAx, [endRow]
   307 00000406 BB08000000          <1>  mov rBx, 8
   307 0000040B 48F7E3              <1>  mul rBx
   307                              <1> 
   307 0000040E 488B98[51000000]    <1>  mov rBx, [checkerboard+rAx]
   307 00000415 488B0D(94030000)    <1>  mov rCx, [endCol]
   307                              <1> 
   308 0000041C 58                                          pop     rAx                             ;// restorr piece
   309 0000041D 88040B                                      mov     [rBx + rCx], AL                  ;// put thr pice into checkerboard at [endRow][endCol]
   310 00000420 E996000000              		    jmp END_MOVE
   311                                  legal_jump:                                                 ;// code below is identical to legal_move, but the end coords arr pushed by one to cause the jump
   312                                                      _startCoords
   312                              <1> 
   312 00000425 488B05(94000000)    <1>  mov rAx, [startRow]
   312 0000042C BB08000000          <1>  mov rBx, 8
   312 00000431 48F7E3              <1>  mul rBx
   312                              <1> 
   312 00000434 488B98[51000000]    <1>  mov rBx, [checkerboard+rAx]
   312 0000043B 488B0D(94010000)    <1>  mov rCx, [startCol]
   312                              <1> 
   313 00000442 4831C0                                      xor     rAx, rAx
   314 00000445 8A040B                                      mov     AL, [rBx + rCx]
   315 00000448 50                                          push    rAx
   316                                  
   317 00000449 4831C0                                      xor     rAx, rAx
   318 0000044C 88040B                                      mov     [rBx + rCx], AL
   319                                  
   320                                                      _endCoords                              ;// rmpty the jumped over space
   320                              <1> 
   320 0000044F 488B05(94020000)    <1>  mov rAx, [endRow]
   320 00000456 BB08000000          <1>  mov rBx, 8
   320 0000045B 48F7E3              <1>  mul rBx
   320                              <1> 
   320 0000045E 488B98[51000000]    <1>  mov rBx, [checkerboard+rAx]
   320 00000465 488B0D(94030000)    <1>  mov rCx, [endCol]
   320                              <1> 
   321 0000046C 4831C0                                      xor     rAx, rAx
   322 0000046F 88040B                                      mov     [rBx + rCx], AL
   323                                  
   324 00000472 488B05(94020000)                            mov     rAx, [endRow]                     ;//converts inout endCoords to proper jump destination
   325 00000479 482B05(94000000)                            sub     rAx, [startRow]
   326 00000480 BB02000000                                  mov     rBx, 2
   327 00000485 48F7EB                                      imul    rBx
   328 00000488 480305(94000000)                            add     rAx, [startRow]
   329 0000048F 488B1CC5[51000000]                          mov     rBx, [checkerboard+8*rAx]
   330                                  
   331 00000497 488B05(94030000)                            mov     rAx, [endCol]                     ;//converts inout endCoords to proper jump destination
   332 0000049E 482B05(94010000)                            sub     rAx, [startCol]
   333 000004A5 B902000000                                  mov     rCx, 2
   334 000004AA 48F7E9                                      imul    rCx
   335 000004AD 480305(94010000)                            add     rAx, [startCol]
   336 000004B4 4889C1                                      mov     rCx, rAx
   337                                  
   338 000004B7 58                                          pop     rAx
   339 000004B8 88040B                                      mov     [rBx + rCx], AL
   340                                  END_MOVE:
   341 000004BB E806000000              		    call kingCheck
   342 000004C0 E83BFBFFFF                                  call outputBoard
   343 000004C5 C3                                          ret
   344                                  
   345                                  kingCheck:
   346                                  
   347 000004C6 4831C9                                      xor     rCx, rCx                        ;// int i = 0
   348 000004C9 4883F908                    FOR1_KC:        cmp     rCx, 8                          ;// i < 8
   349 000004CD 7C02                                        jl      DO1_KC
   350 000004CF EB1D                                        jmp     ENDFOR1_KC
   351                                  
   352 000004D1 4831C0                          DO1_KC:     xor     rAx, rAx                        ;// row = 0
   353 000004D4 488B98[51000000]                            mov     rBx, [checkerboard+rAx]         ;// move the target row into rBx
   354                                  
   355 000004DB 8A040B                                      mov     AL, [rBx + rCx]
   356 000004DE 3C01                                        cmp     AL, 1
   357 000004E0 7402                                        je      KING_ONE
   358 000004E2 EB05                                        jmp     FORNEXT1_KC
   359                                  
   360 000004E4 B003                        KING_ONE:       mov     AL, 3                           ;// replace the 1 in the back row with a 3 (red king)
   361 000004E6 88040B                                      mov     [rBx + rCx], AL
   362                                  
   363                                      FORNEXT1_KC:
   364 000004E9 48FFC1                                      inc     rCx                             ;// i++
   365 000004EC EBDB                                        jmp     FOR1_KC
   366                                      ENDFOR1_KC:
   367 000004EE 4831C9                                      xor     rCx, rCx                        ;// int i = 0
   368 000004F1 4883F908                    FOR2_KC:        cmp     rCx, 8                          ;// i < 8
   369 000004F5 7C02                                        jl      DO2_KC
   370 000004F7 EB23                                        jmp     ENDFOR2_KC
   371                                  
   372 000004F9 4831C0                          DO2_KC:     xor     rAx, rAx                           ;// row = 7
   373 000004FC B807000000              		    mov     rAx, 7
   374 00000501 488B1CC5[51000000]                          mov     rBx, [checkerboard+8*rAx]          ;// move the target row into rBx
   375                                  
   376 00000509 8A040B                                      mov     AL, [rBx + rCx]
   377 0000050C 3C02                                        cmp     Al, 2
   378 0000050E 7402                                        je      KING_TWO
   379 00000510 EB05                                        jmp     FORNEXT2_KC
   380                                  
   381 00000512 B004                        KING_TWO:       mov     AL, 4                           ;// replace the 1 in the back row with a 3 (red king)
   382 00000514 88040B                                      mov     [rBx + rCx], AL
   383                                  
   384                                      FORNEXT2_KC:
   385                                  
   386 00000517 48FFC1                                      inc     rCx                             ;// i++
   387 0000051A EBD5                                        jmp     FOR2_KC
   388                                      ENDFOR2_KC:
   389 0000051C C3                                          ret
