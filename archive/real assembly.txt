
;//Programmer: Nathanael L. Mann
;//Date: 11 Mar 2020
;//Program: Print Integer in any Base

.386
.model flat, stdcall
.stack 4096
ExitProcess PROTO, dwExitCode: DWORD
Includelib Irvine/Irvine32.lib
Includelib Irvine/Kernel32.lib
Includelib Irvine/Users.lib
Include Irvine/Irvine32.inc
WriteString proto
ReadDec proto
WriteDec proto
WriteChar proto

_printLeftB MACRO ;// cout<< "[ "
                push    eDx
                mov     eDx, OFFSET leftB
                call    WriteString
                pop     eDx
endm

_printRightB MACRO ;// cout<< " ]"
                push    eDx
                mov     eDx, OFFSET rightB
                call    WriteString
                pop     eDx
endm

_rowLabel MACRO X ;// cout<< "_" + [current row] + "_"

                IFB <&X>
                    %outm   Error
                    exitm
                ENDIF

                push    eAx             ;// save the registers
                push    eDx
                push    eBx

                xor     eAx, eAx        ;// cout<<"_"
                mov     eAx, 95
                call    WriteChar

                mov     eAx, &X         ;// cout<<"[current row]"
                xor     eDx, eDx
                mov     eBx, 4
                div     eBx
                call    WriteDec

                mov     eAx, 95         ;// cout<<"_"
                call    WriteChar

                pop     eBx             ;// restore the registers
                pop     eDx
                pop     eAx
endm

_startCoords MACRO ;// translates the coordinates in startRow and startCol to [eBx][eCx] fo easy acess.

                mov     eAx, startRow               ;// convert startRow coord into bytes
                mov     eBx, 4
                mul     eBx

                mov     eBx, checkerboard[eAx]      ;// move the target row into eBx
                mov     eCx, startCol

endm

_endCoords MACRO ;// translates the coordinates in endRow and endCol to [eBx][eCx] fo easy acess.

                mov     eAx, endRow                 ;// convert endRow coord into bytes
                mov     eBx, 4
                mul     eBx

                mov     eBx, checkerboard[eAx]      ;// move the target tow into eBx
                mov     eCx, endCol

endm

.data

leftB db "[ ",0
rightB db " ]",0

buffer DWORD 2 dup(?)
filename BYTE "checkerboard.txt",0
fileHandle HANDLE ?

boardHeader db "___|_0_||_1_||_2_||_3_||_4_||_5_||_6_||_7_|",0

row0 db 2, 0, 2, 0, 2, 0, 2, 0
row1 db 0, 2, 0, 2, 0, 2, 0, 2
row2 db 2, 0, 2, 0, 2, 0, 2, 0
row3 db 0, 0, 0, 0, 0, 0, 0, 0
row4 db 0, 0, 0, 0, 0, 0, 0, 0
row5 db 0, 1, 0, 1, 0, 1, 0, 1
row6 db 1, 0, 1, 0, 1, 0, 1, 0
row7 db 0, 1, 0, 1, 0, 1, 0, 1

checkerboard dd row0, row1, row2, row3, row4, row5, row6, row7

startRow dd ?
startCol dd ?
endRow dd ?
endCol dd ?

.code
main proc

                    xor     eCx, eCx                        ;// for (int i = 0)
                    call    outputBoard

RUNPRGM:            push    eCx
                    call    movePiece
                    call    kingCheck
                    call    outputBoard
                    pop     eCx

                    inc     eCx                             ;// (i ++)
RUNWHILE:           cmp     eCx, 1                          ;// (i < 5)                    TODO: CHANGE THIS TO AN ACTUAL LOOP!!!!!!!
                    jl      RUNPRGM                         ;// DO
                    jmp     ENDPRGM                         ;// EXIT

outputBoard proc  
                    mov edx, OFFSET filename                ;// creates a txt file to fill with the boardstate
                    call CreateOutputFile                   ;// so that the rendering info can be sent
                    inc eax
                    mov fileHandle, eax
                    push    eAx

                    mov     eDx, OFFSET boardHeader         ;// VVV
                    call    WriteString                     ;// prints out the header to see coords on board
                    call    CRLF

                    xor     eCx, eCx                        ;// int i = 0
    FOR_outB:       cmp     eCx, 32                         ;// for i < 32
                    jl      DOFOR_outB
                    jmp     ENDFOR_outB

    DOFOR_outB:     mov     eBx, checkerboard[eCx]          ;//puts row[eCx] into eBx for outputRow Function
                    push    eCx
                    _rowLabel   eCX
                    call    outputRow
                    pop     eCx
                    add     eCx, 4                          ;// i+=4

                    jmp     FOR_outB
    ENDFOR_outB:    call    CRLF

                    pop     eAx
                    call    CloseFile
                    ret

outputBoard endp

outputRow proc                                              ;// Requires: eBx = OFFSET rowX
                    xor     eCx, eCx                        ;// int j = 0
    FOR_outR:       cmp     eCx, 8                          ;// for j < 8
                    jl      DOFOR_outR
                    jmp     ENDFOR_outR

    DOFOR_outR:     _printLeftB
                    xor     eAx, eAx                        ;// clear eAx
                    mov     AL, [eBx][eCx]                  ;// VVV
                    call    WriteDec                        ;// cout<< checkerboard[i][j]

                    ;// Output File

                    push    eCx
                    push    eAx

                    add eAx, 48                             ;// puts the value at the specefied index [eBx][eCx] into the file
                    mov buffer, eAx
                    mov edx, OFFSET buffer
                    mov ecx, SIZEOF buffer

                    mov eax, fileHandle
                    mov edx, OFFSET buffer
                    mov ecx, LENGTHOF buffer
                    call WriteToFile

                    pop     eAx
                    pop     eCx

                    _printRightB
                    inc     eCx                             ;// j++
                    jmp     FOR_outR

    ENDFOR_outR:    call    CRLF                            ;//new line
                    
                    ret

outputRow endp

movePiece proc

                    ;// INPUT

                    call    ReadDec                     ;// get coord input
                    mov     startRow, eAx
                    call    ReadDec
                    mov     startCol, eAx
                    call    ReadDec
                    mov     endRow, eAx
                    call    ReadDec
                    mov     endCol, eAx

                    ;// ILLEGAL MOVE: starting square out of bounds
strt_OOB_test:
                    cmp     startRow, 0
                    jl      DO_NOT_MOVE
                    cmp     startRow, 7
                    jg      DO_NOT_MOVE
                    cmp     startCol, 0
                    jl      DO_NOT_MOVE
                    cmp     startCol, 7
                    jg      DO_NOT_MOVE

                    ;// ILLEGAL MOVE: destination square out of bounds
dst_OOB_test:
                    cmp     endRow, 0
                    jl      DO_NOT_MOVE
                    cmp     endRow, 7
                    jg      DO_NOT_MOVE
                    cmp     endCol, 0
                    jl      DO_NOT_MOVE
                    cmp     endCol, 7
                    jg      DO_NOT_MOVE

                    ;// ILLEGAL MOVE: destination square is black
dst_BLK_test:
                    mov     eAx, endRow
                    add     eAx, endCol
                    xor     eDx, eDx
                    mov     eBx, 2                      ;// divide the sum of the coords by 2
                    div     eBx                         ;// since all white spaces contain either two od coords or two even coords, then the sum must be even
                    cmp     eDx, 1                      ;// if the remanider of div 2 is 1, then the destination square must be black
                    je      DO_NOT_MOVE

                    ;// ILLEGAL MOVE: destination square is backwards (or if the starting square is empty)
dst_BACK_test:
                    _startCoords
                    mov     AL, [eBx][eCx]
    IF_P2:          cmp     AL, 2                       ;// if the piece at the startCoords is a 2 (black piece)
                    je      THEN_P2
                    jmp     IF_P1
        THEN_P2:    mov     eAx, startRow               ;// then the piece can only move down the board (positive x)
                    inc     eAx
                    cmp     eAx, endRow
                    jne     DO_NOT_MOVE
                    jmp     ENDIF_P12

                    _startCoords
                    mov     AL, [eBx][eCx]
    IF_P1:          cmp     AL, 1                       ;// if the piece at the startCoords is a 1 (red piece)
                    je      THEN_P1
                    jmp     DO_NOT_MOVE                 ;// if the piece is neither a 1 nor a two, it cannot be moved
        THEN_P1:    mov     eAx, startRow               ;// then the piece can only move down the board (positive x)
                    dec     eAx
                    cmp     eAx, endRow
                    jne     DO_NOT_MOVE

    ENDIF_P12:

                    ;// ILLEGAL MOVE: destination square is occupied (also if the start space is empty)
dst_OCP_test:
                    _startCoords
                    mov     AL, [eBx][eCx]
    IF_O2:          cmp     AL, 2                       ;// if the piece at the start is a 2 (black piece)
                    je      THEN_O2
                    jmp     IF_O1
        THEN_O2:    _endCoords                          ;// then it cannot jump a friendly piece
                    mov     AL, [eBx][eCx]
                    cmp     Al, 2
                    je      DO_NOT_MOVE
                    jmp     ENDIF_O12

    IF_O1:          _startCoords
                    mov     AL, [eBx][eCx]
                    cmp     AL, 1                       ;// if the piece at the start is a 1 (red piece)
                    je      THEN_O1
                    jmp     ENDIF_O12
        THEN_O1:    _endCoords
                    mov     Al, [eBx][eCx]
                    cmp     AL, 1                       ;// then it cannot jump a friendly piece
                    je      DO_NOT_MOVE

    ENDIF_O12:

                    ;// Testing for attempted jump
jmp_test:
                    _startCoords
                    mov     AL, [eBx][eCx]
    IF_J2:          cmp     AL, 2                       ;// if the piece at the start is a 2 (black piece)
                    je      THEN_J2
                    jmp     IF_J1
        THEN_J2:    _endCoords                          ;// and the dest contains an enemy piece
                    mov     AL, [eBx][eCx]
                    cmp     Al, 1
                    je      ENDIF_J12                   ;// check for illegal jump
                    jmp     legal_move                  ;// otherwise, just move normally

    IF_J1:          _startCoords
                    mov     AL, [eBx][eCx]
                    cmp     AL, 1                       ;// if the piece at the start is a 1 (red piece)
                    je      THEN_J1
                    jmp     ENDIF_J12
        THEN_J1:    _endCoords                          ;// and the dest contains an enemy piece
                    mov     Al, [eBx][eCx]
                    cmp     AL, 2
                    je      ENDIF_J12                   ;// check for illegal jump
                    jmp     legal_move                  ;// otherwise, just move normally

    ENDIF_J12:

                    ;// ILLEGAL MOVE: jump is out of bounds
jmp_OOB_test:
                    mov     eAx, endRow                     ;//converts inout endCoords to proper jump destination
                    add     eAx, startRow
                    mov     eBx, 2
                    mul     eBx
                    add     eBx, startRow

                    cmp     eAx, 0
                    jl      DO_NOT_MOVE
                    cmp     eAx, 7
                    jg      DO_NOT_MOVE

                    mov     eAx, endCol                     ;//converts inout endCoords to proper jump destination
                    add     eAx, startCol
                    mov     eCx, 2
                    mul     eCx
                    add     eCx, startCol
                    mov     eCx, eAx

                    cmp     eAx, 0
                    jl      DO_NOT_MOVE
                    cmp     eAx, 7
                    jg      DO_NOT_MOVE

                    ;// ILLEGAL MOVE: jump destination is occupied
jmp_OCP_test:
                    mov     eAx, endRow                     ;//converts inout endCoords to proper jump destination
                    add     eAx, startRow
                    mov     eBx, 2
                    mul     eBx
                    add     eBx, startRow
                    mov     eBx, checkerboard[eAx]

                    mov     eAx, endCol                     ;//converts inout endCoords to proper jump destination
                    add     eAx, startCol
                    mov     eCx, 2
                    mul     eCx
                    add     eCx, startCol
                    mov     eCx, eAx

                    mov     AL, [eBx][eCx]
                    cmp     AL, 0
                    jne     DO_NOT_MOVE
                    jmp     legal_jump

                    ;// LEGAL MOVE OR JUMP:
legal_move:
                    _startCoords                            ;// puts startRow and startCol into [eBx][eCx]
                    xor     eAx, eAx
                    mov     AL, [eBx][eCx]                  ;// move the value at [startRow][startCol] into AL
                    push    eAx                             ;// save the piece to be moved

                    xor     eAx, eAx
                    mov     [eBx][eCx], AL                  ;// empty the space

                    _endCoords                              ;// puts endRow and endCol into [eBx][eCx]
                    pop     eAx                             ;// restore piece
                    mov     [eBx][eCx], AL                  ;// put the pice into checkerboard at [endRow][endCol]
                    ret

legal_jump:                                                 ;// code below is identical to legal_move, but the end coords are pushed by one to cause the jump
                    _startCoords
                    xor     eAx, eAx
                    mov     AL, [eBx][eCx]
                    push    eAx

                    xor     eAx, eAx
                    mov     [eBx][eCx], AL

                    _endCoords                              ;// empty the jumped over space
                    mov     [eBx][eCx], AL

                    mov     eAx, endRow                     ;//converts inout endCoords to proper jump destination
                    add     eAx, startRow
                    mov     eBx, 2
                    mul     eBx
                    add     eBx, startRow
                    mov     eBx, checkerboard[eAx]

                    mov     eAx, endCol                     ;//converts inout endCoords to proper jump destination
                    add     eAx, startCol
                    mov     eCx, 2
                    mul     eCx
                    add     eCx, startCol
                    mov     eCx, eAx

                    pop     eAx
                    mov     [eBx][eCx], AL
DO_NOT_MOVE:
                    ret
movePiece endp

kingCheck proc

                    xor     eCx, eCx                        ;// int i = 0
    FOR1_KC:        cmp     eCx, 8                          ;// i < 8
                    jl      DO1_KC
                    jmp     ENDFOR1_KC

        DO1_KC:     xor     eAx, eAx                        ;// row = 0
                    mov     eBx, checkerboard[eAx]          ;// move the target row into eBx

                    mov     AL, [eBx][eCx]
                    cmp     Al, 1
                    je      KING_ONE
                    jmp     FORNEXT1_KC

    KING_ONE:       mov     AL, 3                           ;// replace the 1 in the back row with a 3 (red king)
                    mov     [eBx][eCx], AL

    FORNEXT1_KC:
                    inc     eCx                             ;// i++
                    jmp     FOR1_KC
    ENDFOR1_KC:
                    xor     eCx, eCx                        ;// int i = 0
    FOR2_KC:        cmp     eCx, 8                          ;// i < 8
                    jl      DO2_KC
                    jmp     ENDFOR2_KC

        DO2_KC:     mov     eAx, 28                         ;// row = 7
                    mov     eBx, checkerboard[eAx]          ;// move the target row into eBx

                    mov     AL, [eBx][eCx]
                    cmp     Al, 2
                    je      KING_TWO
                    jmp     FORNEXT2_KC

    KING_TWO:       mov     AL, 4                           ;// replace the 1 in the back row with a 3 (red king)
                    mov     [eBx][eCx], AL

    FORNEXT2_KC:

                    inc     eCx                             ;// i++
                    jmp     FOR2_KC
    ENDFOR2_KC:
                    ret
kingCheck endp

ENDPRGM:            call    CRLF

INVOKE ExitProcess, 0
main ENDP
END main